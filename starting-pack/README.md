
# Explore California Web-site

This is a repacking of Carlos Nunez training "Kubernetes: Your First Project"


## Project steps
This is a web project used for leaning purposes to deploy a simpel Kubernets deployment on Kubernets cluster
The Kubernetes cluster used is build using Kubenretes In Docker KIND: https://kind.sigs.k8s.io/

Steps may be long so be patient

* Create an Ubuntu 22.04 server VM to host all our work
* choose a nice hostname for the VM
    ```bash
    sudo hostnamectl set-hostname k8s-project
    ```
    And add your user as passwordless sudoer, make sure to replace $USER with your actual used username
    ```bash
    sudo vim /etc/sudoers.d/${USER}_user # And add the below line
    $USER All=(ALL) NOPASSWD: ALL
    ```

* (Option) To play nice you can configure static IPs for the VM using netplan: https://www.linuxtechi.com/static-ip-address-on-ubuntu-server/
* Install Docker
    ```bash
    # Add Docker's official GPG key:
    sudo apt update
    sudo apt install ca-certificates curl
    sudo install -m 0755 -d /etc/apt/keyrings
    sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
    sudo chmod a+r /etc/apt/keyrings/docker.asc

    # Add the repository to Apt sources:
    echo \
    "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
    $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | \
    sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
    sudo apt update

    # Install Docker
    sudo apt install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin

    # To be able to run docker command using your user without sudo, you need to add your user to docker group created by docker binary during installation
    sudo usermod -aG docker $USER
    newgrp docker
    ```
* We will be following same idea Carlos did to do staff using make file so we need to install make, Let's get a very short brief of what is Make
    > Makefiles, in simple terms, are files that provide an easy and optimal
    > solution for building and re-building any executable through make rules
    
    What a Rule looks like?
    ```make
    target … : prerequisites …
        recipe
        …
        …
    ```
    > A **target** is usually the name of a file that is generated by a program; examples of targets are executable or object files. A target can also be the name of an action to carry out, such as ‘clean’

    > A **prerequisite** is a file that is used as input to create the target. A target often depends on several files.

    > A **recipe** is an action that make carries out. A recipe may have more than one command, either on the same line or each on its own line. Please note: you `need to put a tab character at the beginning of every recipe line! This is an obscurity that catches the unwary

    > A **phony target** is one that is not really the name of a file; rather it is just a name for a recipe to be executed when you make an explicit request. There are two reasons to use a phony target: to avoid a conflict with a file of the same name, and to improve performance

* We are going to start with the website files in "website" directory, Dockerfile and build on it step by step
* Install make
    ```bash
    sudo apt install -y build-essential
    ```
* The website used for this deployment is a simple website based on Nginx
* Let's start by building the image and testing if the docker image build successfully, can run and we can access it. Let's build the image
    ```bash
    docker build -t explorecalifornia-image .
    ```
* Test the image by running a container
    ```bash
    docker run --rm --name explorecalifornia -p 8000:80
    ```
* Since we are running this container in a VM we need to do SSH tunel to be able to access the VM on port 80. (Will leave it for you with a hint: https://www.tecmint.com/create-ssh-tunneling-port-forwarding-in-linux/)
* Let's start creating out Makefile, first rules we will do will be what we just did by building and testing running container
    ```make
    vim Makefile # And add the below lines to it
    #!/usr/bin/env make

    run_website:
	    docker build -t explorecalifornia.com . && \
		    docker run -p 5000:80 -d --name explorecalifornia.com --rm explorecalifornia.com
    ```
    If we just create it like this it will create a file named run_website and for the second run it will require a deletion, Since we are not using Make for building a real artifacts and just for being single automation tool we will have to make this target as a PHONY target, and also all out next targets. This can be done by adding ".PHONY: run_website" to the start of the Makefile, so new Makefile will be like:

    ```make
    #!/usr/bin/env make

    .PHONY: run_website

    run_website:
	    docker build -t explorecalifornia-image . && \
		    docker run --rm -p 8000:80 -d --name explorecalifornia explorecalifornia-image
    ```
    * Now let's test by running this Makefile and see what we have
        ```bash
        make run_website
        ```
    * Let's add another make rule to stop the website
    ``` make
    #!/usr/bin/env make

    .PHONY: run_website stop_website

    run_website:
	    docker build -t explorecalifornia-image . && \
		    docker run --rm -p 8000:80 -d --name explorecalifornia explorecalifornia-image
    
    stop_website:
        docker stop explorecalifornia
    ```
> Let's do all next steps inside the Makefile using ruels and takeing care dependent targets

*  Let's install KIND as the Kubernetes cluster for hosting the website. We are using Ubuntu 22.04 server so we can follow documentation: https://kind.sigs.k8s.io/docs/user/quick-start/#installing-from-release-binaries
But we will do that through the Makefile
    ```make
    #!/usr/bin/env make

    .PHONY: run_website stop_website install_kind

    run_website:
	    docker build -t explorecalifornia-image . && \
		    docker run --rm -p 8000:80 -d --name explorecalifornia explorecalifornia-image
    
    stop_website:
        docker stop explorecalifornia

    install_kind:
	    curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.22.0/kind-linux-amd64; \
	    chmod +x ./kind && \
		    sudo mv ./kind /usr/local/bin/kind
    ```
* Before we create a KIND cluster we will need to have kubectl command installed to be able interact with the KIND cluster so let's a new rule to install kubectl on Ubuntu 22.04. There are multiple ways we can go for the official one: https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/ 
Now the Makefile will be like
    ```make
    #!/usr/bin/env make

    .PHONY: run_website stop_website install_kind install_kubectl

    run_website:
	    docker build -t explorecalifornia-image . && \
		    docker run --rm -p 8000:80 -d --name explorecalifornia explorecalifornia-image
    
    stop_website:
        docker stop explorecalifornia

    install_kind:
	    curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.22.0/kind-linux-amd64; \
	    chmod +x ./kind && \
		    sudo mv ./kind /usr/local/bin/kind

    install_kubectl:
	    curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.30/deb/Release.key | sudo gpg --dearmor --yes -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg; \
        sudo chmod 644 /etc/apt/keyrings/kubernetes-apt-keyring.gpg; \
	    echo 'deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.30/deb/ /' | sudo tee /etc/apt/sources.list.d/kubernetes.list; \
        sudo chmod 644 /etc/apt/sources.list.d/kubernetes.list; \
	    sudo apt update && \
		    sudo apt install -y kubectl; \
	    sudo cp -v /usr/bin/kubectl /usr/local/bin/kubectl
    ```
* Now let's add a rule to create KIND cluster
    ```make
    #!/usr/bin/env make

    .PHONY: run_website stop_website install_kind install_kubectl \
            create_kind_cluster

    run_website:
	    docker build -t explorecalifornia-image . && \
		    docker run --rm -p 8000:80 -d --name explorecalifornia explorecalifornia-image
    
    stop_website:
        docker stop explorecalifornia

    install_kind:
	    curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.22.0/kind-linux-amd64; \
	    chmod +x ./kind && \
		    sudo mv ./kind /usr/local/bin/kind

    install_kubectl:
	    curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.30/deb/Release.key | sudo gpg --dearmor --yes -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg; \
        sudo chmod 644 /etc/apt/keyrings/kubernetes-apt-keyring.gpg; \
	    echo 'deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.30/deb/ /' | sudo tee /etc/apt/sources.list.d/kubernetes.list; \
        sudo chmod 644 /etc/apt/sources.list.d/kubernetes.list; \
	    sudo apt update && \
		    sudo apt install -y kubectl; \
	    sudo cp -v /usr/bin/kubectl /usr/local/bin/kubectl

    create_kind_cluster:
        kind create cluster --name explorecalifornia-cluster && \
            kubectl get nodes
    ```
* Since we will be building our own application, let's mimic what happens in enterprises. They host thier SW in private registry so we are going to use the simplest one and create a private docker registry. Let's test the creation and how it works using docker commands first
    ```bash
    docker run --name local-registry -d --restart=always -p 5000:5000 registry:2
    ```
    To verify it is running and ready to host repos and images let;s query it
    ```bash
    curl -L http://localhost:5000/v2
    ```
* Let's Add make rule to create docker registry. We are checking if it is created before creating the registry to avoid errors
    ```make
    #!/usr/bin/env make

    .PHONY: run_website stop_website install_kind install_kubectl \
            create_kind_cluster create_docker_registry

    run_website:
	    docker build -t explorecalifornia-image . && \
		    docker run --rm -p 8000:80 -d --name explorecalifornia explorecalifornia-image
    
    stop_website:
        docker stop explorecalifornia

    install_kind:
	    curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.22.0/kind-linux-amd64; \
	    chmod +x ./kind && \
		    sudo mv ./kind /usr/local/bin/kind

    install_kubectl:
	    curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.30/deb/Release.key | sudo gpg --dearmor --yes -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg; \
        sudo chmod 644 /etc/apt/keyrings/kubernetes-apt-keyring.gpg; \
	    echo 'deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.30/deb/ /' | sudo tee /etc/apt/sources.list.d/kubernetes.list; \
        sudo chmod 644 /etc/apt/sources.list.d/kubernetes.list; \
	    sudo apt update && \
		    sudo apt install -y kubectl; \
	    sudo cp -v /usr/bin/kubectl /usr/local/bin/kubectl

    create_kind_cluster:
        kind create cluster --name explorecalifornia-cluster && \
            kubectl get nodes

    create_docker_registry:
	    if ! docker ps | grep -q 'local-registry'; \
	    then docker run -d -p 5000:5000 --name local-registry --restart=always registry:2; \
	    else echo "---> local-registry is already running. There's nothing to do here."; \
	    fi
    ```

* At this stage we have a KIND cluster and a private docker registry but KIND don't know anything about the registry we created. we need to link KIND to the docker registry. we ill make use of KIND configuration file to do this. More options for KIND config file are here: https://kind.sigs.k8s.io/docs/user/quick-start/#advanced
* KIND is using containerd as a CRI and we simpy need to tell containerd to use local registry for searching about images
    ```ini
      [plugins."io.containerd.grpc.v1.cri".registry.mirrors."localhost:5000"]
        endpoint = ["http://local-registry:5000"]
    ```

* Let's do this configs inside KIND config yaml file
    ```yaml
    kind: Cluster
    apiVersion: kind.x-k8s.io/v1alpha4
    containerdConfigPatches:
    - |-
      [plugins."io.containerd.grpc.v1.cri".registry.mirrors."localhost:5000"]
        endpoint = ["http://local-registry:5000"]
    nodes:
    - role: control-plane
      kubeadmConfigPatches:
      - |
        kind: InitConfiguration
        nodeRegistration:
          kubeletExtraArgs:
            node-labels: "ingress-ready=true"
      extraPortMappings:
      - containerPort: 80
        hostPort: 80
        protocol: TCP
      - containerPort: 443
        hostPort: 443
        protocol: TCP
    ```
* Next we have to need to tell KIND that we are using a local registry by creating a simple configMap as below
    ```yaml
    apiVersion: v1
    kind: ConfigMap
    metadata:
      name: local-registry-hosting
      namespace: kube-public
    data:
      localRegistryHosting.v1: |
        host: "localhost:${reg_port}"
        help: "https://kind.sigs.k8s.io/docs/user/local-registry/"
    ```

* Now to change the KIND InitConfiguration we need to delete and recreate the cluster so let's do that in Makefile
    ```make
    #!/usr/bin/env make

    .PHONY: run_website stop_website install_kind install_kubectl \
            create_kind_cluster create_docker_registry create_kind_cluster \


    run_website:
	    docker build -t explorecalifornia-image . && \
		    docker run --rm -p 8000:80 -d --name explorecalifornia explorecalifornia-image
    
    stop_website:
        docker stop explorecalifornia

    install_kind:
	    curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.22.0/kind-linux-amd64; \
	    chmod +x ./kind && \
		    sudo mv ./kind /usr/local/bin/kind

    install_kubectl:
	    curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.30/deb/Release.key | sudo gpg --dearmor --yes -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg; \
        sudo chmod 644 /etc/apt/keyrings/kubernetes-apt-keyring.gpg; \
	    echo 'deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.30/deb/ /' | sudo tee /etc/apt/sources.list.d/kubernetes.list; \
        sudo chmod 644 /etc/apt/sources.list.d/kubernetes.list; \
	    sudo apt update && \
		    sudo apt install -y kubectl; \
	    sudo cp -v /usr/bin/kubectl /usr/local/bin/kubectl

    create_kind_cluster:
        kind create cluster --name explorecalifornia-cluster && \
            kubectl get nodes

    create_docker_registry:
	    if ! docker ps | grep -q 'local-registry'; \
	    then docker run -d -p 5000:5000 --name local-registry --restart=always registry:2; \
	    else echo "---> local-registry is already running. There's nothing to do here."; \
	    fi

    create_kind_cluster: install_kind install_kubectl create_docker_registry
	    kind create cluster --image=kindest/node:v1.21.12 --name explorecalifornia.com --config ./kind_config.yaml || true
	    kubectl get nodes
    ```

* What we have done so far is just letting KIND know about the private registry, but we still need to make the docker registry container be able to connect to KIND created container for the cluster. Let's do that also through Makefile
    ```make
    #!/usr/bin/env make

    .PHONY: run_website stop_website install_kind install_kubectl \
            create_kind_cluster create_docker_registry create_kind_cluster \
            create_kind_cluster_with_registry connect_registry_to_kind_network \
            connect_registry_to_kind 

    run_website:
	    docker build -t explorecalifornia-image . && \
		    docker run --rm -p 8000:80 -d --name explorecalifornia explorecalifornia-image
    
    stop_website:
        docker stop explorecalifornia

    install_kind:
	    curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.22.0/kind-linux-amd64; \
	    chmod +x ./kind && \
		    sudo mv ./kind /usr/local/bin/kind

    install_kubectl:
	    curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.30/deb/Release.key | sudo gpg --dearmor --yes -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg; \
        sudo chmod 644 /etc/apt/keyrings/kubernetes-apt-keyring.gpg; \
	    echo 'deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.30/deb/ /' | sudo tee /etc/apt/sources.list.d/kubernetes.list; \
        sudo chmod 644 /etc/apt/sources.list.d/kubernetes.list; \
	    sudo apt update && \
		    sudo apt install -y kubectl; \
	    sudo cp -v /usr/bin/kubectl /usr/local/bin/kubectl

    create_kind_cluster:
        kind create cluster --name explorecalifornia-cluster && \
            kubectl get nodes

    create_docker_registry:
	    if ! docker ps | grep -q 'local-registry'; \
	    then docker run -d -p 5000:5000 --name local-registry --restart=always registry:2; \
	    else echo "---> local-registry is already running. There's nothing to do here."; \
	    fi

    create_kind_cluster: install_kind install_kubectl create_docker_registry
	    kind create cluster --image=kindest/node:v1.21.12 --name explorecalifornia.com --config ./kind_config.yaml || true
	    kubectl get nodes

    connect_registry_to_kind_network:
	    docker network connect kind local-registry || true;

    connect_registry_to_kind: connect_registry_to_kind_network
	    kubectl apply -f ./kind_configmap.yaml;
    
    create_kind_cluster_with_registry:
	    $(MAKE) create_kind_cluster && $(MAKE) connect_registry_to_kind
    ```
    > We've used here a special make rule variables $(MAKE) which launches another instance of make with the actual make path appended to it

* To test the what we did we will need to delete KIND cluster so let's do that using Makfile. To cleanup we will need to delete docker private registry created also so let's add this deleteion make rule
    ```make
    #!/usr/bin/env make

    .PHONY: run_website stop_website install_kind install_kubectl \
            create_kind_cluster create_docker_registry create_kind_cluster \
            create_kind_cluster_with_registry connect_registry_to_kind_network \
            connect_registry_to_kind delete_kind_cluster delete_docker_registry \


    run_website:
	    docker build -t explorecalifornia-image . && \
		    docker run --rm -p 8000:80 -d --name explorecalifornia explorecalifornia-image
    
    stop_website:
        docker stop explorecalifornia

    install_kind:
	    curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.22.0/kind-linux-amd64; \
	    chmod +x ./kind && \
		    sudo mv ./kind /usr/local/bin/kind

    install_kubectl:
	    curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.30/deb/Release.key | sudo gpg --dearmor --yes -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg; \
        sudo chmod 644 /etc/apt/keyrings/kubernetes-apt-keyring.gpg; \
	    echo 'deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.30/deb/ /' | sudo tee /etc/apt/sources.list.d/kubernetes.list; \
        sudo chmod 644 /etc/apt/sources.list.d/kubernetes.list; \
	    sudo apt update && \
		    sudo apt install -y kubectl; \
	    sudo cp -v /usr/bin/kubectl /usr/local/bin/kubectl

    create_kind_cluster:
        kind create cluster --name explorecalifornia-cluster && \
            kubectl get nodes

    create_docker_registry:
	    if ! docker ps | grep -q 'local-registry'; \
	    then docker run -d -p 5000:5000 --name local-registry --restart=always registry:2; \
	    else echo "---> local-registry is already running. There's nothing to do here."; \
	    fi

    create_kind_cluster: install_kind install_kubectl create_docker_registry
	    kind create cluster --image=kindest/node:v1.21.12 --name explorecalifornia.com --config ./kind_config.yaml || true
	    kubectl get nodes

    connect_registry_to_kind_network:
	    docker network connect kind local-registry || true;

    connect_registry_to_kind: connect_registry_to_kind_network
	    kubectl apply -f ./kind_configmap.yaml;
    
    create_kind_cluster_with_registry:
	    $(MAKE) create_kind_cluster && $(MAKE) connect_registry_to_kind

    delete_kind_cluster: delete_docker_registry
	    kind delete cluster --name explorecalifornia.com

    delete_docker_registry:
	    docker stop local-registry && docker rm local-registry
    ```

* Let's start creating our first deployment. we will make use of the dry-run=client paramters to help us generate the YAML manifest of the deployment
    ```bash
    kubectl create deployment --dry-run=client --image localhost:5000/explorecalifornia-image explorecalifornia-dep --output=yaml > deployment.yaml
    ```

* Before creating the deployment we need to add the explorecalifornia image to the local registry so that deployment can pull it when it is started
    ```bash
    docker tag explorecalifornia-image localhost:5000/explorecalifornia-image
    docker push localhost:5000/explorecalifornia-image
    ```
* Let's try creating the deployment
    ```bash
    kubectl apply -f deployment.yaml
    kubectl get po -l app=explorecalifornia-dep
    ```
* To test the access you will need to have two things: The SSH tunnel to the VM which is still left for you to figure out and the KIND port forwaring
    ```bash
    kubectl port-forward deployment/explorecalifornia-dep 8080:80
    ```
    Then try to access it from your laptop browser
* Now we have only access to the website from only Kubernetes cluster network to enable access from outside we need two resources to be created: Service and Ingress
* Let's create the service to enable fixed clusterIP access and traffic distribution when we scale
    ```bash
    kubectl create service clusterip --dry-run=client --tcp=80:80 explorecalifornia-dep --output=yaml > service.yaml
    ```
* Let's verify we can access if we exposed the service instead of the deployment
    ```bash
    kubectl port-forward service/explorecalifornia-svc 8080:80
    ```

* To complete the service exposure we will need to create "ingress" kubernetes resource but this won't make it alone and will need a thirdparty "ingressController" and we will use the simplest one for this which is Nginx: https://kind.sigs.k8s.io/docs/user/ingress/

* Create the ingress resource 
    ```bash
    kubectl create ingress explorecalifornia-ing --rule="explorecalifornia.com/=explorecalifornia-svc:80" --dry-run=client --output=yaml > ingress.yaml
    ```
    This will create the below file
    ```yaml
    apiVersion: networking.k8s.io/v1
    kind: Ingress
    metadata:
      creationTimestamp: null
      name: explorecalifornia.com
    spec:
      rules:
      - host: explorecalifornia.com
        http:
          paths:
          - backend:
              service:
                name: explorecalifornia-svc
                port:
                  number: 80
            path: /
            pathType: Exact
    status:
      loadBalancer: {}
    ```
    Since the website has multiple pathes for images we just need to relax the 'pathType' to be Prefix instead of Exact and cleanup 'creationTimestamp' and 'status' blocks

* Then we need to configure KIND to use ingress resource and install ingressController, more details in the KIND docs: https://kind.sigs.k8s.io/docs/user/ingress/

* As per KIND ingress documentation we simply need to add kubelet arguments to label control node with "ingress-ready=true" by adding below snippet to KIND configs and add external port mappings over ports 80 and 443
    ```yaml
    kubeadmConfigPatches:
  - |
      kind: InitConfiguration
      nodeRegistration:
        kubeletExtraArgs:
          node-labels: "ingress-ready=true"
    ```
    > If you noticed this was already present in the KIND config files we used before to create the KIND cluster
* To test how ingress work we need to first apply the ingress resource
    ```bash
    kubectl apply -f ingress.yaml
    ```
* As we noticed in the ingress resource we need to access the website using FQDN "explorecalifornia.com" not the VMs IP so do do that in the current setup we need to add the below entry on both VMs /etc/hosts file and your laptop Windows hosts file
    ```bash
    127.0.0.1 explorecalifornia.com
    ```
    then create the SSH tunnel to the VM and try to access the website on the laptop using http://explorecalifornia.com:8000/index.htm

## Create a Helm chart fo the website
There are multiple ways to easily create a Helm chart, using helm create command of manually creating files and directories to create the chart which we will do for the simplicity of the application

We will follow the same automation using Makefile, Let's walk step by step

* Let's install Helm on the Ubuntu 22.04 VM using snap via Makfile rule
    ```make
    #!/usr/bin/env make

    .PHONY: run_website stop_website install_kind install_kubectl \
            create_kind_cluster create_docker_registry create_kind_cluster \
            create_kind_cluster_with_registry connect_registry_to_kind_network \
            connect_registry_to_kind delete_kind_cluster delete_docker_registry \
            install_helm_ubuntu

    run_website:
	    docker build -t explorecalifornia-image . && \
		    docker run --rm -p 8000:80 -d --name explorecalifornia explorecalifornia-image
    
    stop_website:
        docker stop explorecalifornia

    install_kind:
	    curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.22.0/kind-linux-amd64; \
	    chmod +x ./kind && \
		    sudo mv ./kind /usr/local/bin/kind

    install_kubectl:
	    curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.30/deb/Release.key | sudo gpg --dearmor --yes -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg; \
        sudo chmod 644 /etc/apt/keyrings/kubernetes-apt-keyring.gpg; \
	    echo 'deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.30/deb/ /' | sudo tee /etc/apt/sources.list.d/kubernetes.list; \
        sudo chmod 644 /etc/apt/sources.list.d/kubernetes.list; \
	    sudo apt update && \
		    sudo apt install -y kubectl; \
	    sudo cp -v /usr/bin/kubectl /usr/local/bin/kubectl

    create_kind_cluster:
        kind create cluster --name explorecalifornia-cluster && \
            kubectl get nodes

    create_docker_registry:
	    if ! docker ps | grep -q 'local-registry'; \
	    then docker run -d -p 5000:5000 --name local-registry --restart=always registry:2; \
	    else echo "---> local-registry is already running. There's nothing to do here."; \
	    fi

    create_kind_cluster: install_kind install_kubectl create_docker_registry
	    kind create cluster --image=kindest/node:v1.21.12 --name explorecalifornia.com --config ./kind_config.yaml || true
	    kubectl get nodes

    connect_registry_to_kind_network:
	    docker network connect kind local-registry || true;

    connect_registry_to_kind: connect_registry_to_kind_network
	    kubectl apply -f ./kind_configmap.yaml;
    
    create_kind_cluster_with_registry:
	    $(MAKE) create_kind_cluster && $(MAKE) connect_registry_to_kind

    delete_kind_cluster: delete_docker_registry
	    kind delete cluster --name explorecalifornia.com

    delete_docker_registry:
	    docker stop local-registry && docker rm local-registry
    
    install_helm_ubuntu:
	    sudo snap install helm --classic
    ```

* Let's create a chart, any Helm chart should have the below structure
        
        
        wordpress/
        Chart.yaml          # A YAML file containing information about the
        chart
        LICENSE             # OPTIONAL: A plain text file containing the license for the chart
        README.md           # OPTIONAL: A human-readable README file
        values.yaml         # The default configuration values for this chart
        values.schema.json  # OPTIONAL: A JSON Schema for imposing a structure on the values.yaml file
        charts/             # A directory containing any charts upon which this chart depends.
        crds/               # Custom Resource Definitions
        templates/          # A directory of templates that, when combined with values, # will generate valid Kubernetes manifest files.
        templates/NOTES.txt # OPTIONAL: A plain text file containing short usage notes
        ```
    So we start by creating minimum mandatory chart structure
    ```bash
    mkdir chart
    mkdir chart/templates
    ```

    Create the Chart.yaml file with the below metadata about the chart and versioning
    ```bash
    cd chart
    vim Chart.yaml
    ```
    ```yaml
    apiVersion: v2
    name: explore-california-website
    version: 1.0.0
    deprecated: false
    appVersion: 1.0.0
    ```

* Create the chart's values.yaml file containing needed values to be replaced in the website deployment
    ```bash
    vim chart/values.yaml
    ```

    ```yaml
    appName: explorecalifornia-com
    imageName: localhost:5000/explorecalifornia.com
    serviceName: explorecalifornia-svc
    serviceAddress: explorecalifornia.com
    servicePort: 8080
    replicas: 2
    ```

* Validate the chart to see if there is a n error
    ```bash
    helm show all ./chart
    ```

* Templatize the deployment by replaving the fixed values in the deployment, service and ingress by helm variables added to the values.yaml file

    The deployment.yaml file should look like below:
    ```yaml
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      labels:
        app: {{ .Values.appName }}
      name: {{ .Values.appName }}
    spec:
      replicas: {{ .Values.replicas }}
      selector:
        matchLabels:
          app: {{ .Values.appName }}
      strategy: {}
      template:
        metadata:
          labels:
            app: {{ .Values.appName }}
        spec:
          imagePullSecrets:
            - name: {{ .Values.imagePullSecretName }}
          containers:
          - image: {{ .Values.imageName }}
            name: {{ .Values.appName }}-{{ randAlpha 10 | lower }}
            ports:
              - containerPort: 80
            resources: {}
    ```

    service.yaml should look like below:
    ```yaml
        apiVersion: v1
    kind: Service
    metadata:
      creationTimestamp: null
      labels:
        app: {{ .Values.appName }}
      name: {{ .Values.serviceName }}
    spec:
      ports:
      - name: http
        port: {{ .Values.servicePort }}
        protocol: TCP
        targetPort: 80
      selector:
        app: {{ .Values.appName }}
      type: ClusterIP
    status:
      loadBalancer: {}

    ```

    Ingress resource
    ```yaml
    apiVersion: networking.k8s.io/v1
    kind: Ingress
    metadata:
      name: {{ .Values.appName }}
    spec:
      rules:
      - http:
          paths:
          - backend:
              service:
                name: {{ .Values.serviceName }}
                port:
                  number: {{ .Values.servicePort }}
            path: /
            pathType: Prefix
    ```

* Now copy the deployment.yaml, ingress.yaml, service.yaml to chart/templates directory
    ```bash
    cp -v {deployment,ingress,service}.yaml chart/templates
    ```
* To get a rendered version of the chart manifests which helps if there is an unexpected issue with chart deployment
    ```bash
    helm template ./chart
    ```

* Let's add the chart helm install to our Makefile
    ```make
    #!/usr/bin/env make

    .PHONY: run_website stop_website install_kind install_kubectl \
            create_kind_cluster create_docker_registry create_kind_cluster \
            create_kind_cluster_with_registry connect_registry_to_kind_network \
            connect_registry_to_kind delete_kind_cluster delete_docker_registry \
            install_helm_ubuntu

    run_website:
	    docker build -t explorecalifornia-image . && \
		    docker run --rm -p 8000:80 -d --name explorecalifornia explorecalifornia-image
    
    stop_website:
        docker stop explorecalifornia

    install_kind:
	    curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.22.0/kind-linux-amd64; \
	    chmod +x ./kind && \
		    sudo mv ./kind /usr/local/bin/kind

    install_kubectl:
	    curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.30/deb/Release.key | sudo gpg --dearmor --yes -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg; \
        sudo chmod 644 /etc/apt/keyrings/kubernetes-apt-keyring.gpg; \
	    echo 'deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.30/deb/ /' | sudo tee /etc/apt/sources.list.d/kubernetes.list; \
        sudo chmod 644 /etc/apt/sources.list.d/kubernetes.list; \
	    sudo apt update && \
		    sudo apt install -y kubectl; \
	    sudo cp -v /usr/bin/kubectl /usr/local/bin/kubectl

    create_kind_cluster:
        kind create cluster --name explorecalifornia-cluster && \
            kubectl get nodes

    create_docker_registry:
	    if ! docker ps | grep -q 'local-registry'; \
	    then docker run -d -p 5000:5000 --name local-registry --restart=always registry:2; \
	    else echo "---> local-registry is already running. There's nothing to do here."; \
	    fi

    create_kind_cluster: install_kind install_kubectl create_docker_registry
	    kind create cluster --image=kindest/node:v1.21.12 --name explorecalifornia.com --config ./kind_config.yaml || true
	    kubectl get nodes

    connect_registry_to_kind_network:
	    docker network connect kind local-registry || true;

    connect_registry_to_kind: connect_registry_to_kind_network
	    kubectl apply -f ./kind_configmap.yaml;
    
    create_kind_cluster_with_registry:
	    $(MAKE) create_kind_cluster && $(MAKE) connect_registry_to_kind

    delete_kind_cluster: delete_docker_registry
	    kind delete cluster --name explorecalifornia.com

    delete_docker_registry:
	    docker stop local-registry && docker rm local-registry
    
    install_helm_ubuntu:
	    sudo snap install helm --classic

    install_app_helm: install_helm_ubuntu
	    helm upgrade --atomic --install explore-california-website ./chart
    ```

    > We are using helm upgrade in order to enabling chart modification and versioning instead of introducing conflicting helm install commands

* 